<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Flappy Bird ‚Äì Fullscreen</title>
  <style>
    :root {
      --bg: #70c5ce;
      --ground: #ded895;
      --pipe: #2ecc71;
      --pipe-dark: #27ae60;
      --bird: #ffcc00;
      --text: #0f172a;
      --shadow: 0 8px 28px rgba(0,0,0,.22);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      touch-action: none; /* Prevent double-tap zoom on Android */
      -webkit-tap-highlight-color: transparent;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
    }

    #wrap {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
    }

    canvas {
      width: 100vw;  /* Fill screen on Android */
      height: 100vh;
      display: block;
      background: linear-gradient(#87ceeb, var(--bg));
    }

    /* HUD */
    .hud {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;  /* let taps reach canvas */
    }

    .score {
      font-weight: 800;
      font-size: clamp(20px, 5vw, 32px);
      text-shadow: 0 2px 0 rgba(255,255,255,.8);
    }

    .btn {
      pointer-events: auto;
      appearance: none;
      border: none;
      outline: none;
      padding: 12px 16px;
      border-radius: 16px;
      background: white;
      box-shadow: var(--shadow);
      font-weight: 700;
      font-size: 14px;
    }

    .center-overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    .card {
      pointer-events: auto;
      width: min(92vw, 460px);
      background: rgba(255,255,255,.96);
      border-radius: 24px;
      padding: 20px 18px 16px;
      box-shadow: var(--shadow);
      text-align: center;
      backdrop-filter: blur(8px);
    }

    .title {
      font-size: clamp(22px, 6vw, 32px);
      margin: 0 0 6px 0;
    }

    .subtitle {
      margin: 0 0 12px 0;
      opacity: .8;
    }

    .row { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }

    .hide { display: none !important; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
  </div>

  <div class="hud">
    <div class="score" id="score">0</div>
    <div class="row">
      <button class="btn" id="pauseBtn" aria-label="Pause">‚è∏Ô∏è</button>
      <button class="btn" id="soundBtn" aria-label="Sound">üîä</button>
    </div>
  </div>

  <div class="center-overlay" id="startOverlay">
    <div class="card">
      <h2 class="title">Flappy Bird</h2>
      <p class="subtitle">Tap anywhere to flap ¬∑ Avoid the pipes</p>
      <div class="row">
        <button class="btn" id="startBtn">Start</button>
      </div>
    </div>
  </div>

  <div class="center-overlay hide" id="gameOverOverlay">
    <div class="card">
      <h3 class="title">Game Over</h3>
      <p class="subtitle">Score: <span id="finalScore">0</span> ¬∑ Best: <span id="bestScore">0</span></p>
      <div class="row">
        <button class="btn" id="restartBtn">Restart</button>
        <button class="btn" id="menuBtn">Menu</button>
      </div>
    </div>
  </div>

  <script>
    // --- Canvas Setup (HiDPI aware) ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function fitCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const vw = Math.max(1, window.innerWidth);
      const vh = Math.max(1, window.innerHeight);
      canvas.style.width = vw + 'px';
      canvas.style.height = vh + 'px';
      canvas.width = Math.floor(vw * dpr);
      canvas.height = Math.floor(vh * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS px
    }
    fitCanvas();
    window.addEventListener('resize', fitCanvas);
    window.addEventListener('orientationchange', () => setTimeout(fitCanvas, 100));

    // --- Simple sound (optional, lightweight) ---
    let soundOn = true;
    function ping(freq = 600, dur = 0.06, vol = 0.04) {
      if (!soundOn || typeof AudioContext === 'undefined') return;
      const actx = ping.ctx || (ping.ctx = new (window.AudioContext || window.webkitAudioContext)());
      const o = actx.createOscillator();
      const g = actx.createGain();
      o.type = 'sine';
      o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g).connect(actx.destination);
      o.start();
      o.stop(actx.currentTime + dur);
    }

    // --- Game State ---
    const HUD = {
      score: document.getElementById('score'),
      startOverlay: document.getElementById('startOverlay'),
      gameOverOverlay: document.getElementById('gameOverOverlay'),
      finalScore: document.getElementById('finalScore'),
      bestScore: document.getElementById('bestScore'),
      pauseBtn: document.getElementById('pauseBtn'),
      soundBtn: document.getElementById('soundBtn'),
      startBtn: document.getElementById('startBtn'),
      restartBtn: document.getElementById('restartBtn'),
      menuBtn: document.getElementById('menuBtn'),
    };

    let state = 'ready'; // 'ready' | 'playing' | 'paused' | 'gameover'
    let score = 0;
    let best = Number(localStorage.getItem('fb_best') || 0);
    HUD.bestScore.textContent = best;

    // Physics tuned for mobile smoothness
    const physics = {
      gravity: 1800, // px/s^2
      jump: -450,   // px/s
      maxFall: 900, // clamp fall speed
      scroll: 160,  // px/s world speed
    };

    const bird = {
      x: 96,
      y: 0,
      vy: 0,
      r: 16,
      rot: 0,
    };

    function resetBird() {
      bird.x = Math.max(64, Math.min(140, canvas.width / (window.devicePixelRatio || 1) * 0.25));
      bird.y = canvas.height / (window.devicePixelRatio || 1) * 0.4;
      bird.vy = 0;
      bird.rot = 0;
    }

    let pipes = [];
    const pipeConf = {
      gap: () => Math.max(150, Math.min(240, Math.round(window.innerHeight * 0.24))),
      width: 64,
      spacingMs: 1400, // time between pipes
      lastAt: 0,
    };

    function addPipePair() {
      const h = window.innerHeight;
      const gap = pipeConf.gap();
      const minTop = 60;
      const maxTop = Math.max(minTop + 40, h - gap - 140);
      const top = Math.floor(Math.random() * (maxTop - minTop + 1)) + minTop;
      pipes.push({ x: window.innerWidth + 20, top, gap, passed: false });
    }

    function resetGame() {
      score = 0; HUD.score.textContent = '0';
      pipes = [];
      pipeConf.lastAt = 0;
      resetBird();
    }

    // --- Controls ---
    function flap() {
      if (state === 'ready') startGame();
      if (state !== 'playing') return;
      bird.vy = physics.jump;
      bird.rot = -0.35;
      ping(800, 0.05, 0.05);
    }

    function startGame() {
      resetGame();
      state = 'playing';
      HUD.startOverlay.classList.add('hide');
      HUD.gameOverOverlay.classList.add('hide');
    }

    function gameOver() {
      state = 'gameover';
      HUD.finalScore.textContent = score;
      if (score > best) { best = score; localStorage.setItem('fb_best', String(best)); }
      HUD.bestScore.textContent = best;
      HUD.gameOverOverlay.classList.remove('hide');
      ping(180, 0.15, 0.06);
    }

    function togglePause() {
      if (state === 'playing') state = 'paused';
      else if (state === 'paused') state = 'playing';
      HUD.pauseBtn.textContent = state === 'playing' ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
    }

    // Touch / Pointer
    window.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'mouse' && e.button !== 0) return;
      e.preventDefault();
      if (state === 'gameover') return; // use Restart button
      flap();
    }, { passive: false });

    // Keyboard (desktop testing)
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); flap(); }
      if (e.code === 'KeyP') togglePause();
      if (e.code === 'Enter' && state === 'ready') startGame();
      if (e.code === 'Enter' && state === 'gameover') { startGame(); }
    });

    HUD.pauseBtn.addEventListener('click', () => togglePause());
    HUD.soundBtn.addEventListener('click', () => {
      soundOn = !soundOn;
      HUD.soundBtn.textContent = soundOn ? 'üîä' : 'üîá';
      ping(600, 0.05, 0.04);
    });
    HUD.startBtn.addEventListener('click', startGame);
    HUD.restartBtn.addEventListener('click', () => { startGame(); });
    HUD.menuBtn.addEventListener('click', () => {
      state = 'ready';
      HUD.gameOverOverlay.classList.add('hide');
      HUD.startOverlay.classList.remove('hide');
      resetGame();
    });

    // --- Drawing helpers ---
    function drawBird() {
      const { x, y, r } = bird;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(bird.rot);
      // body
      ctx.fillStyle = 'white';
      ctx.beginPath(); ctx.arc(0, 0, r + 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bird').trim();
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
      // beak
      ctx.fillStyle = '#ff8c00';
      ctx.beginPath();
      ctx.moveTo(r - 4, -4);
      ctx.lineTo(r + 10, 0);
      ctx.lineTo(r - 4, 4);
      ctx.closePath();
      ctx.fill();
      // eye
      ctx.fillStyle = '#111827';
      ctx.beginPath(); ctx.arc(4, -4, 3, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    }

    function drawPipes(dt) {
      const pipeW = pipeConf.width;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pipe').trim();
      for (const p of pipes) {
        // top pipe
        ctx.fillRect(p.x, 0, pipeW, p.top);
        // cap
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pipe-dark').trim();
        ctx.fillRect(p.x - 4, p.top - 20, pipeW + 8, 20);
        // restore main color
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pipe').trim();
        // bottom pipe
        const bottomY = p.top + p.gap;
        const h = window.innerHeight - bottomY - 60;
        ctx.fillRect(p.x, bottomY, pipeW, h);
        // cap
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pipe-dark').trim();
        ctx.fillRect(p.x - 4, bottomY, pipeW + 8, 20);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pipe').trim();
      }
    }

    function drawGround(scrollX) {
      const h = 60;
      const y = window.innerHeight - h;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground').trim();
      ctx.fillRect(0, y, window.innerWidth, h);
      // simple stripes
      ctx.globalAlpha = 0.2;
      for (let x = (-scrollX % 40) - 40; x < window.innerWidth; x += 40) {
        ctx.fillRect(x, y + 20, 20, 6);
      }
      ctx.globalAlpha = 1;
    }

    // --- Game Loop ---
    let last = performance.now();
    let scrollX = 0;

    function step(now) {
      requestAnimationFrame(step);
      const rawDt = (now - last) / 1000;
      last = now;
      // Clamp dt for stability when tab resumes
      const dt = Math.min(0.033, Math.max(0.0, rawDt));

      // Clear
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      // Background clouds (subtle)
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = 'rgba(255,255,255,.8)';
      const cw = window.innerWidth, ch = window.innerHeight;
      const cloudSpeed = 12;
      const cx = (now * 0.02) % (cw + 200);
      circle(cw - cx, ch * 0.2, 22);
      circle(cw - cx * 0.7, ch * 0.3, 16);
      circle(cw - cx * 1.2, ch * 0.15, 18);
      ctx.globalAlpha = 1;

      if (state === 'playing') {
        // Spawn pipes
        pipeConf.lastAt += dt * 1000;
        if (pipeConf.lastAt > pipeConf.spacingMs) {
          pipeConf.lastAt = 0;
          addPipePair();
        }

        // Update pipes
        for (const p of pipes) {
          p.x -= physics.scroll * dt;
          if (!p.passed && p.x + pipeConf.width < bird.x) {
            p.passed = true; score++; HUD.score.textContent = String(score); ping(1000, 0.04, 0.05);
          }
        }
        // Remove offscreen
        pipes = pipes.filter(p => p.x + pipeConf.width > -40);

        // Update bird physics
        bird.vy += physics.gravity * dt;
        bird.vy = Math.min(bird.vy, physics.maxFall);
        bird.y += bird.vy * dt;
        const targetRot = bird.vy > 0 ? 0.6 : -0.35;
        bird.rot += (targetRot - bird.rot) * Math.min(1, dt * 8);

        // Scroll ground parallax
        scrollX += physics.scroll * dt;

        // Collisions
        const groundY = window.innerHeight - 60;
        if (bird.y + bird.r > groundY) { bird.y = groundY - bird.r; return gameOver(); }
        if (bird.y - bird.r < 0) { bird.y = bird.r; bird.vy = 0; }

        for (const p of pipes) {
          const inX = bird.x + bird.r > p.x && bird.x - bird.r < p.x + pipeConf.width;
          if (inX) {
            const topEnd = p.top;
            const bottomStart = p.top + p.gap;
            if (bird.y - bird.r < topEnd || bird.y + bird.r > bottomStart) {
              return gameOver();
            }
          }
        }
      }

      // Draw world
      drawPipes(dt);
      drawGround(scrollX);
      drawBird();

      // Ready text hint
      if (state === 'ready') {
        ctx.fillStyle = 'rgba(0,0,0,.65)';
        ctx.font = '700 20px system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign = 'center';
        ctx.fillText('Tap to start ¬∑ Tap to flap', window.innerWidth / 2, window.innerHeight * 0.65);
      }

      // Paused overlay (subtle)
      if (state === 'paused') {
        ctx.fillStyle = 'rgba(0,0,0,.25)';
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        ctx.fillStyle = 'white';
        ctx.font = '800 28px system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign = 'center';
        ctx.fillText('Paused', window.innerWidth / 2, window.innerHeight / 2);
      }
    }

    function circle(x, y, r) {
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
    }

    resetGame();
    requestAnimationFrame(step);
  </script>
</body>
</html>
